{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red15\green112\blue1;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red144\green1\blue18;\red19\green118\blue70;\red108\green18\blue48;}
{\*\expandedcolortbl;;\cssrgb\c0\c50196\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c52549\c34510;\cssrgb\c50588\c12157\c24706;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 #### Assignment - An agent-based digital forensics system in Python\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 #### Importing Modules\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 import\cf0 \strokec4  re \cf2 \strokec2 # Regex for email address matching\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  nltk \cf2 \strokec2 # For NLP tasks\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  threading \cf2 \strokec2 # For running multiple threads (subprocess) concurrently in Python\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 import\cf0 \strokec4  os \cf2 \strokec2 # For using operating-system dependent functionality. In this case - to open a .txt email file, \cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3           \cf2 \strokec2 # read contents, and properly close the file (Python Software Foundation, 2024).\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 from\cf0 \strokec4  collections \cf5 \strokec5 import\cf0 \strokec4  Counter \cf2 \strokec2 # To count the occurences of elements in an iterable or mapping object\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  nltk.tokenize \cf5 \strokec5 import\cf0 \strokec4  word_tokenize \cf2 \strokec2 # To split text into word or tokens\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 from\cf0 \strokec4  nltk.corpus \cf5 \strokec5 import\cf0 \strokec4  stopwords \cf2 \strokec2 # Common words (the, and, is) that are often filtered out from text data \cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3                                   \cf2 \strokec2 # for lack of significant meaning\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 #nltk.download('stopwords') # If the package is not already installed in the user's system\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 #nltk.download('punkt') # If the package is not already installed in the user's system\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 # Directory containing email text files\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # For the presentation, the dataset was downloaded (Cohen, 2015).\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 EMAIL_DATA_DIR = \cf6 \strokec6 "/Users/rosh/Documents/GitHub/eportfolio/Final Assignment/Directory_all"\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 # Defines a set of stopwords in English\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 stop_words = set(stopwords.words(\cf6 \strokec6 'english'\cf0 \strokec4 ))\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 #### Define agents\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 ### Coordinator Agent \cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 class\cf0 \strokec4  CoordinatorAgent:\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf2 \strokec2 # Method takes 2 parameters - \cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # 1. self: current instance of the class; \cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # 2. evidence: expected parameter by method when creating an instance of the class\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  __init__(self, evidence):\cb1 \
\cb3         \cf2 \strokec2 # - allows each instance of the class to have its own 'evidence' value\cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 # Evidence = suspect personnel names (as an example) for this case\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .evidence = evidence\cb1 \
\
\cb3         \cf2 \strokec2 # The following lines initialize the 'results', 'frequent_terms', and \cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 # 'top_senders' attributes of the class instance to an empty list\cf0 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 # - stores the results of the analysis performed by the digital forensics system as\cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 #   they are generated during investigation\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .results = []\cb1 \
\
\cb3         \cf2 \strokec2 # - stores the frequently used terms discovered during the analysis performed by \cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 # the digital forensics system \cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .frequent_terms = []\cb1 \
\
\cb3         \cf2 \strokec2 # - stores the information about the top senders of emails discovered during\cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 # the analysis performed by the digital forensics system\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .top_senders = []\cb1 \
\
\cb3     \cf5 \strokec5 def\cf0 \strokec4  coordinate_search(self):\cb1 \
\cb3             print(\cf6 \strokec6 "Coordinator Agent: Starting search coordination..."\cf0 \strokec4 )\cb1 \
\
\cb3             \cf2 \strokec2 # Dataset that is being used for design has a mix of file types (.cats and .txt)\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # The following line creates a list of filenames 'email_files' in the\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # directory specified by EMAIL_DATA_DIR that have the .txt extension\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # These filenames represent text files containing email data that will be\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # processed further in the code\cf0 \cb1 \strokec4 \
\
\cb3             \cf2 \strokec2 # 1. os.listdir(EMAIL_DATA_DIR) - function - returns a list os strings representing\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #    all files/directory names in the specified directory\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # 2. if f.endswith('.txt') - conditional statement - filters list of files\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #    obtained from #1. It conducts a T/F check if each filename 'f' ends with .txt extension\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # 3. f for f in... - list comprehension - iterates over each 'f' obtained\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #    from function and filters them based on the condition\cf0 \cb1 \strokec4 \
\cb3             email_files = [f \cf5 \strokec5 for\cf0 \strokec4  f \cf5 \strokec5 in\cf0 \strokec4  os.listdir(EMAIL_DATA_DIR) \cf5 \strokec5 if\cf0 \strokec4  f.endswith(\cf6 \strokec6 '.txt'\cf0 \strokec4 )]\cb1 \
\
\cb3             print(\cf5 \strokec5 f\cf6 \strokec6 "Coordinator Agent: Found \cf0 \strokec4 \{len(email_files)\}\cf6 \strokec6  email files."\cf0 \strokec4 )\cb1 \
\
\cb3             \cf2 \strokec2 ## Read emails from each text file\cf0 \cb1 \strokec4 \
\
\cb3             \cf2 \strokec2 # Empty list - stores contents of all email files\cf0 \cb1 \strokec4 \
\cb3             emails = []\cb1 \
\
\cb3             \cf2 \strokec2 # Loop iterates over each filename in 'email_files' list\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 for\cf0 \strokec4  file \cf5 \strokec5 in\cf0 \strokec4  email_files:\cb1 \
\
\cb3                 \cf2 \strokec2 # Opens each email file 'file' located in the directory for reading 'r' mode\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # 1. 'os.path.join() - function - constructs the full path to the email file being opened\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 #     - joins 1 or more path components (in this case - joins the directory path\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 #       with the filename 'file' to create the full path to the email file\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # 2. open(...) - built-in Python function - used to open a file and return a corresponding file object\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # 3. as f: assigns the file object returned by open() to 'f' variable\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # 4. 'f' - variable - used as a file handle within the indented block of \cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 #          code following the 'with' statement\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # 5. with - statement - ensures file is properly closed after its suite\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 #           finishes\cf0 \cb1 \strokec4 \
\cb3                 \cf5 \strokec5 with\cf0 \strokec4  open(os.path.join(EMAIL_DATA_DIR, file), \cf6 \strokec6 'r'\cf0 \strokec4 ) \cf5 \strokec5 as\cf0 \strokec4  f:\cb1 \
\
\cb3                     \cf2 \strokec2 # Reads contents of the current email file 'f' and splits it \cf0 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 # into individual emails based the delimiter "---"\cf0 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 # Each email stored as a separate element in the email_content list\cf0 \cb1 \strokec4 \
\cb3                     email_content = f.read().split(\cf6 \strokec6 '---'\cf0 \strokec4 )\cb1 \
\
\cb3                     \cf2 \strokec2 # Extends the 'emails' list with the contents of the email_content list\cf0 \cb1 \strokec4 \
\cb3                     \cf2 \strokec2 # Combines all emails from all files into a single list\cf0 \cb1 \strokec4 \
\cb3                     emails.extend(email_content)\cb1 \
\
\cb3             \cf2 \strokec2 ## Create and start search agent instances that will search for evidence in the emails\cf0 \cb1 \strokec4 \
\cb3                     \cb1 \
\cb3             \cf2 \strokec2 # Creates a list of new instances of the 'SearchAgent' class (i.e. 'search_agents') for each email\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # 1. Each object is initialized with an email content 'email.strip()', the evidence\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #    'self.evidence' and reference to the CoordinatorAgent object 'self'         \cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # 2. for email in emails - iteraters over each email in the 'emails' list. \cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #    - each 'email' represents the content of an email as a string\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # 3. email.strip - 'strip()' method is called on each 'email' which removes \cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #                   leading and trailing whitespace (whitespace characters such\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 #                   as newline characters) from the string (email content)\cf0 \cb1 \strokec4 \
\cb3             search_agents = [SearchAgent(email.strip(), \cf5 \strokec5 self\cf0 \strokec4 .evidence, \cf5 \strokec5 self\cf0 \strokec4 ) \cf5 \strokec5 for\cf0 \strokec4  email \cf5 \strokec5 in\cf0 \strokec4  emails]\cb1 \
\
\cb3             print(\cf5 \strokec5 f\cf6 \strokec6 "Coordinator Agent: Activating \cf0 \strokec4 \{len(search_agents)\}\cf6 \strokec6  search agents..."\cf0 \strokec4 )\cb1 \
\cb3             \cb1 \
\cb3             \cf2 \strokec2 # Loop - iterates over each 'SearchAgent' object in the 'search_agents' list\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 for\cf0 \strokec4  agent \cf5 \strokec5 in\cf0 \strokec4  search_agents:\cb1 \
\
\cb3                 \cf2 \strokec2 # Method - starts execution of run() method of each 'SearchAgent' object\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # in a  separate thread. Each thread will search for evidence in the\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # email content assigned to it\cf0 \cb1 \strokec4 \
\cb3                 agent.start()\cb1 \
\
\cb3             \cf2 \strokec2 ## Loop - waits for each 'SearchAgent' thread to finish its execution before next steps\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 for\cf0 \strokec4  agent \cf5 \strokec5 in\cf0 \strokec4  search_agents:\cb1 \
\
\cb3                 \cf2 \strokec2 # Method ensures that main thread waits for all search agents to\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # finish their tasks before proceeding\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # Important to ensure all email searches are completed before moving\cf0 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 # on to the analysis phase\cf0 \cb1 \strokec4 \
\cb3                 agent.join()\cb1 \
\
\cb3             \cf2 \strokec2 ## Method called on the self object after all search agents have finished\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 ## execution. Performs analysis on the results obtained from the search\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 self\cf0 \strokec4 .analyze_results()\cb1 \
\
\cb3     \cf2 \strokec2 # Method to extract emails from the text files\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # Additionally added to support the analyze_results method, because it was originally unable \cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # to extract all relevant email addresses\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # The following code now splits each line, and the sender email is therefore easily extracted\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  extract_email(self, text):\cb1 \
\
\cb3         email_lines = text.split(\cf6 \strokec6 '\\n'\cf0 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 for\cf0 \strokec4  line \cf5 \strokec5 in\cf0 \strokec4  email_lines:\cb1 \
\cb3             \cf5 \strokec5 if\cf0 \strokec4  \cf6 \strokec6 "From:"\cf0 \strokec4  \cf5 \strokec5 in\cf0 \strokec4  line:\cb1 \
\cb3                 \cf5 \strokec5 return\cf0 \strokec4  line.split(\cf6 \strokec6 ":"\cf0 \strokec4 )[\cf7 \strokec7 1\cf0 \strokec4 ].strip()\cb1 \
\cb3         \cf5 \strokec5 return\cf0 \strokec4  \cf6 \strokec6 ""\cf0 \cb1 \strokec4 \
\cb3     \cb1 \
\cb3     \cf2 \strokec2 # Method processes emails that matched the evidence, counts the occurrences\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # of the words and sender email addresses, and prints out the results\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  analyze_results(self): \cb1 \
\cb3         \cb1 \
\cb3             \cf2 \strokec2 ## Count frequently used terms\cf0 \cb1 \strokec4 \
\
\cb3             \cf2 \strokec2 # Tokenization and stopword removal -\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # Helps system to modify the raw text to be able to better focus on relevant\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # words, and improves accuracy of entity detection (Mielke et al., 2021)\cf0 \cb1 \strokec4 \
\cb3             all_words = [word_tokenize(email.lower()) \cf5 \strokec5 for\cf0 \strokec4  email \cf5 \strokec5 in\cf0 \strokec4  \cf5 \strokec5 self\cf0 \strokec4 .results]\cb1 \
\cb3             all_words = [word \cf5 \strokec5 for\cf0 \strokec4  sublist \cf5 \strokec5 in\cf0 \strokec4  all_words \cf5 \strokec5 for\cf0 \strokec4  word \cf5 \strokec5 in\cf0 \strokec4  sublist \cf5 \strokec5 if\cf0 \strokec4  word.isalnum() \cf5 \strokec5 and\cf0 \strokec4  word \cf5 \strokec5 not\cf0 \strokec4  \cf5 \strokec5 in\cf0 \strokec4  stop_words]\cb1 \
\cb3             \cb1 \
\cb3             \cf2 \strokec2 # Creates a Counter object 'word_counts' from the list of all words\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # Counter - to count occurences of elements in a list\cf0 \cb1 \strokec4 \
\cb3             word_counts = Counter(all_words)\cb1 \
\
\cb3             \cf2 \strokec2 # Extracts five most common words + their counts from 'word_counts'\cf0 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 # and assigns them to attribute 'self.frequent_terms'\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 self\cf0 \strokec4 .frequent_terms = word_counts.most_common(\cf7 \strokec7 5\cf0 \strokec4 )\cb1 \
\
\cb3             \cf2 \strokec2 ## Count top senders\cf0 \cb1 \strokec4 \
\
\cb3             \cf2 \strokec2 # Extracts the sender information from each email in self.results\cf0 \cb1 \strokec4 \
\
\cb3             sender_emails = []\cb1 \
\cb3             \cf5 \strokec5 for\cf0 \strokec4  email \cf5 \strokec5 in\cf0 \strokec4  \cf5 \strokec5 self\cf0 \strokec4 .results:\cb1 \
\cb3                 email_header = \cf5 \strokec5 self\cf0 \strokec4 .extract_email(email)\cb1 \
\cb3                 \cf2 \strokec2 #print(email)\cf0 \cb1 \strokec4 \
\
\cb3                 \cf2 \strokec2 # Define a regular expression pattern to match email addresses\cf0 \cb1 \strokec4 \
\cb3                 email_sender = re.findall(\cf5 \strokec5 r\cf8 \strokec8 '\\b[A-Za-z0-9._%+-]\cf0 \strokec4 +\cf8 \strokec8 @[A-Za-z0-9.-]\cf0 \strokec4 +\cf8 \strokec8 \\.[A-Z|a-z]\cf0 \strokec4 \{2,\}\cf8 \strokec8 \\b'\cf0 \strokec4 , email_header)\cb1 \
\cb3                 \cf2 \strokec2 #print(email_sender)\cf0 \cb1 \strokec4 \
\cb3                 \cf5 \strokec5 if\cf0 \strokec4  email_sender:\cb1 \
\cb3                     sender_emails.extend(email_sender)\cb1 \
\cb3                     \cf2 \strokec2 #print(sender_emails)\cf0 \cb1 \strokec4 \
\cb3             sender_counts = Counter(sender_emails)\cb1 \
\cb3             \cf2 \strokec2 #print(sender_counts)\cf0 \cb1 \strokec4 \
\
\cb3             \cf2 \strokec2 # Extracts two most common sender email addresses and their counts\cf0 \cb1 \strokec4 \
\cb3             \cf5 \strokec5 self\cf0 \strokec4 .top_senders = sender_counts.most_common(\cf7 \strokec7 2\cf0 \strokec4 )\cb1 \
\cb3             \cb1 \
\cb3             \cf2 \strokec2 ## Print results\cf0 \cb1 \strokec4 \
\cb3             print(\cf6 \strokec6 "Coordinator Agent: Analysis completed."\cf0 \strokec4 )\cb1 \
\cb3             \cb1 \
\cb3             \cf2 \strokec2 # The following prints out frequently used terms (along with their counts)\cf0 \cb1 \strokec4 \
\cb3             print(\cf6 \strokec6 "Frequently used terms:"\cf0 \strokec4 , \cf5 \strokec5 self\cf0 \strokec4 .frequent_terms)\cb1 \
\cb3             \cf2 \strokec2 # The following prints out top sender email addresses (along with their counts)\cf0 \cb1 \strokec4 \
\cb3             print(\cf6 \strokec6 "Top senders:"\cf0 \strokec4 , \cf5 \strokec5 self\cf0 \strokec4 .top_senders)\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     def save_results(self): \cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             # Placeholder for saving results to a file/database\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             pass    \cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             \cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     def display_results(self): \cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             print("Frequently used terms:")\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             \cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             # Iterates over each item in the self.frequent_terms list \cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             # Each item in the list = tuple containing a term and its count\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             for term, count in self.frequent_terms:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                 print(f"\{term\}: \{count\}")\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             print("\\nTop senders:")\cf0 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6             # Each item in the list = tuple containing a sender's email address and its count\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6             for sender, count in self.top_senders:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6                 print(f"\{sender\}: \{count\}")\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 ### Search Agent \cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # Inherits from threading.Thread (i.e. SearchAgent is a thread that can run concurrently\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # with other threads (Python Software Foundation, 2024).\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # Thread that searches for evidence in the email content and communicates findings\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # to CoordinatorAgent (if matches are found)        \cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 # Threading is important for this system to achieve concurrent execution of tasks, by\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # allowing for multi-core parallelism (granted smooth coordination between multi-threaded parties)\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 # (Malakhov, 2016)\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 class\cf0 \strokec4  SearchAgent(threading.Thread): \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf2 \strokec2 # Constructor method takes these parameters:\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # 1. Email - email content to be searched for evidence\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # 2. Evidence - list of evidence to be searched for\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # 3. Coordinator - a reference to the 'CoordinatorAgent' instance, allowing the\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 #                  'SearchAgent' to communicate its findings\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  __init__(self, email, evidence, coordinator): \cb1 \
\cb3         threading.Thread.__init__(\cf5 \strokec5 self\cf0 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .email = email\cb1 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .evidence = evidence\cb1 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .coordinator = coordinator\cb1 \
\
\cb3     \cf2 \strokec2 # Method called when 'SearchAgent' thread starts executing\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # Overrides the 'run' method of the 'Thread' class\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  run(self): \cb1 \
\
\cb3         print(\cf5 \strokec5 f\cf6 \strokec6 "Search Agent: Starting search for evidence in email: \cf0 \strokec4 \{\cf5 \strokec5 self\cf0 \strokec4 .email[:\cf7 \strokec7 50\cf0 \strokec4 ]\}\cf6 \strokec6 ..."\cf0 \strokec4 )\cb1 \
\
\cb3         \cf2 \strokec2 # Search_email method called to search for evidence in the email content\cf0 \cb1 \strokec4 \
\cb3         matches = \cf5 \strokec5 self\cf0 \strokec4 .search_email(\cf5 \strokec5 self\cf0 \strokec4 .email, \cf5 \strokec5 self\cf0 \strokec4 .evidence)\cb1 \
\cb3         \cb1 \
\cb3         \cf2 \strokec2 # If matches is not empty/evidence is found, email content and evidence \cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 # matches are appended to the 'results' list of the 'CoordinatorAgent'\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 if\cf0 \strokec4  matches:\cb1 \
\cb3             \cf5 \strokec5 self\cf0 \strokec4 .coordinator.results.append(\cf5 \strokec5 self\cf0 \strokec4 .email)\cb1 \
\cb3             print(\cf5 \strokec5 f\cf6 \strokec6 "Search Agent: Evidence found in email: \cf0 \strokec4 \{\cf5 \strokec5 self\cf0 \strokec4 .email[:\cf7 \strokec7 50\cf0 \strokec4 ]\}\cf6 \strokec6 "\cf0 \strokec4 )\cb1 \
\cb3         \cf5 \strokec5 else\cf0 \strokec4 :\cb1 \
\cb3             print(\cf5 \strokec5 f\cf6 \strokec6 "Search Agent: No evidence found in email: \cf0 \strokec4 \{\cf5 \strokec5 self\cf0 \strokec4 .email[:\cf7 \strokec7 50\cf0 \strokec4 ]\}\cf6 \strokec6 "\cf0 \strokec4 )    \cb1 \
\
\cb3     \cf2 \strokec2 # Helper method used by 'run' method to search for evidence in email content\cf0 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  search_email(self, email, evidence): \cb1 \
\
\cb3         \cf2 \strokec2 # Tokenizes email, converts text to lowercase, and removes stopwords\cf0 \cb1 \strokec4 \
\cb3         tokens = word_tokenize(email.lower())\cb1 \
\cb3         filtered_tokens = [word \cf5 \strokec5 for\cf0 \strokec4  word \cf5 \strokec5 in\cf0 \strokec4  tokens \cf5 \strokec5 if\cf0 \strokec4  word.isalnum() \cf5 \strokec5 and\cf0 \strokec4  word \cf5 \strokec5 not\cf0 \strokec4  \cf5 \strokec5 in\cf0 \strokec4  stop_words]\cb1 \
\
\cb3         \cf2 \strokec2 # Checks for matches between the filtered tokens and the provided evidence\cf0 \cb1 \strokec4 \
\cb3         matches = [word \cf5 \strokec5 for\cf0 \strokec4  word \cf5 \strokec5 in\cf0 \strokec4  filtered_tokens \cf5 \strokec5 if\cf0 \strokec4  word \cf5 \strokec5 in\cf0 \strokec4  evidence]\cb1 \
\
\cb3         \cf5 \strokec5 return\cf0 \strokec4  matches\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 ### Analysis Agent \cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 class\cf0 \strokec4  AnalysisAgent: \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf5 \strokec5 def\cf0 \strokec4  __init__(self, data): \cb1 \
\cb3         \cf5 \strokec5 self\cf0 \strokec4 .data = data\cb1 \
\cb3     \cb1 \
\cb3     \cf5 \strokec5 def\cf0 \strokec4  analyze_data(self): \cb1 \
\
\cb3         \cf2 \strokec2 # Placeholder for analysis logic\cf0 \cb1 \strokec4 \
\cb3         \cf5 \strokec5 pass\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 if\cf0 \strokec4  __name__ == \cf6 \strokec6 "__main__"\cf0 \strokec4 :\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf2 \strokec2 # Sample evidence\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 # Remediation for error - make sure strings are lowercase\cf0 \cb1 \strokec4 \
\cb3     evidence = [\cf6 \strokec6 "term1"\cf0 \strokec4 , \cf6 \strokec6 "term2"\cf0 \strokec4 ]\cb1 \
\
\cb3     \cf2 \strokec2 # Create and start CoordinatorAgent\cf0 \cb1 \strokec4 \
\cb3     coordinator = CoordinatorAgent(evidence)\cb1 \
\cb3     coordinator.coordinate_search()\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     # Save and display results\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     coordinator.save_results()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     coordinator.display_results()\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\
\
\
\
\
}